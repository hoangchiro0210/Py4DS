# -*- coding: utf-8 -*-
"""TensorFlow.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EPsgF8RM-X0bCuvHpd7BDx4R0O-Kxn5F

# ********************************************Load a pandas.DataFrame***************************
#                                             |                     |
#                                             |_____________________|

## ********************************************1. Read data ************************************
"""

import pandas as pd
import tensorflow as tf

csv_file = tf.keras.utils.get_file('heart.csv', 'https://storage.googleapis.com/download.tensorflow.org/data/heart.csv')

# Đọc dữ liệu bằng tensorflow

"""Read the csv file using pandas."""

df = pd.read_csv(csv_file)

# Đọc dữ liệu bằng pandas

df.head()

df.dtypes

df['thal'] = pd.Categorical(df['thal'])
df['thal'] = df.thal.cat.codes
#   Chuyển dữ liệu từ obj sang int

df.head()

"""##**********************************2.Load data using `tf.data.Dataset`******************************"""

target = df.pop('target')

dataset = tf.data.Dataset.from_tensor_slices((df.values, target.values))

#   hàm tf.data.Dataset.from_tensor_slices dùng để đọc dữ liệu từ dataframe

for feat, targ in dataset.take(10):
  print ('Features: {}, Target: {}'.format(feat, targ))

  #   in ra feature và target của 5 dòng đầu

"""Since a `pd.Series` implements the `__array__` protocol it can be used transparently nearly anywhere you would use a `np.array` or a `tf.Tensor`."""

tf.constant(df['thal'])
#   Tương tự như np.array , hàm này dùng để tạo array từ cột 'thal' của data frame

"""Shuffle and batch the dataset."""

train_dataset = dataset.shuffle(len(df)).batch(1)

#   Hàm shuffle dùng để Trộn ngẫu nhiên một tensor dọc theo chiều thứ nhất của nó.
#   Hàm batch sẽ gom các phần tử lại thành một tập hợp lớn dựa trên tham số nhập vào
#   Trong hàm batch trên chỉ lấy 1 phần tử

"""## ****************************************3.Create and train a model**************************"""

def get_compiled_model():
  model = tf.keras.Sequential([
    tf.keras.layers.Dense(10, activation='relu'),
    tf.keras.layers.Dense(10, activation='relu'),
    tf.keras.layers.Dense(1)
  ])

  model.compile(optimizer='adam',
                loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
                metrics=['accuracy'])
  return model



#   tf.keras.Sequential : Tuần tự nhóm một chồng lớp tuyến tính thành một tf.keras.Model.
#   Sequential cung cấp các tính năng đào tạo và suy luận trên mô hình này


#   tf.keras.layers.Dense : Dense triển khai hoạt động: đầu ra = kích hoạt (dấu chấm (đầu vào, kernel) + khuynh hướng) 
#   trong đó kích hoạt là hàm kích hoạt phần tử được chuyển làm đối số kích hoạt,


#   model.compile : Phương thức compile  chỉ định tổn thất, số liệu và trình tối ưu hóa


#   Hàm trên dùng để compile model

model = get_compiled_model()
model.fit(train_dataset, epochs=15)

#   Tham số epoch : được sử dụng để tách tập train thành các phần riêng biệt.

"""## ************************************** 4.Alternative to feature columns ***********************************

Passing a dictionary as an input to a model is as easy as creating a matching dictionary of `tf.keras.layers.Input` layers, applying any pre-processing and stacking them up using the [functional api](../../guide/keras/functional.ipynb). You can use this as an alternative to [feature columns](../keras/feature_columns.ipynb).
"""

inputs = {key: tf.keras.layers.Input(shape=(), name=key) for key in df.keys()}
x = tf.stack(list(inputs.values()), axis=-1)

x = tf.keras.layers.Dense(10, activation='relu')(x)
output = tf.keras.layers.Dense(1)(x)

model_func = tf.keras.Model(inputs=inputs, outputs=output)

model_func.compile(optimizer='adam',
                   loss=tf.keras.losses.BinaryCrossentropy(from_logits=True),
                   metrics=['accuracy'])


#   tf.stack : Xếp một danh sách các tensor bậc R thành một tensor bậc- (R + 1).

"""The easiest way to preserve the column structure of a `pd.DataFrame` when used with `tf.data` is to convert the `pd.DataFrame` to a `dict`, and slice that dictionary."""

dict_slices = tf.data.Dataset.from_tensor_slices((df.to_dict('list'), target.values)).batch(16)

# Tạo ra data từ df có dạng dict và giá trị của target sau đó gom 16 phần tử lại thành 1 mảng 



# Ví dụ :

# dataset = tf.data.Dataset.from_tensor_slices([8, 3, 0, 8, 2, 1]).batch(4)
# for elem in dataset:
#   print(elem.numpy())

# Kết quả :
# [8 3 0 8]
# [2 1]

for dict_slice in dict_slices.take(2):
  print (dict_slice)


#   In ra các phần tử bên trong của dict_slice

model_func.fit(dict_slices, epochs=15)

#   fit model
